forecastnnetar <- forecast(fit_nnetar, h=h)$mean
nnetarACCURACY <- ACCURACY(forecast=forecastnnetar, test=test, training=training)
return(nnetarACCURACY)
}
# season naive method
SNAIVE <- function(ts_info, ACCURACY){
training <- ts_info$training
test <- ts_info$test
forecastSNAIVE <- snaive(training, h=length(test))$mean
SNAIVEaccuracy <- ACCURACY(forecast=forecastSNAIVE, test=test, training=training)
return(SNAIVEaccuracy)
}
# mstl
MSTL <- function(ts_info, ACCURACY){
training <- ts_info$training
test <- ts_info$test
fit_mstl <- mstl(training)
forecastMSTL <- forecast(training, h=length(test))$mean
MSTLaccuracy <- ACCURACY(forecast=forecastMSTL, test=test, training=training)
return(MSTLaccuracy)
}
# TBATS
TBATS <- function(ts_info, ACCURACY){
training <- ts_info$training
test <- ts_info$test
fitTBAT <- tbats(training)
forecastTBATS <- forecast(fitTBAT, h=h)$mean
TBATSaccuracy <- ACCURACY(forecast=forecastTBATS, test=test, training=training)
return(TBATSaccuracy)
}
fcast_accuracy(tslist=tslist,models= c("rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
# Theta Method
THETA <- function(ts_info, ACCURACY){
training <- ts_info$training
test <- ts_info$test
m <- frequency(training)
if (m > 1){
# using stheta method with seasonal adjustment
# require(forecTheta)
forecastTheta <- stheta(training,h=h, s='additive')$mean
THETAaccuracy <- ACCUARACY(forecast=forecastTheta, test=test, training=training)
} else {
# using thetaf method
forecastTheta <-thetaf(training,h=length(test))$mean
THETAaccuracy <- ACCURACY(forecast=forecastTheta, test=test, training=training)
}
return(THETAaccuracy)
}
fcast_accuracy(tslist=tslist,models= c("rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
models = c("ets", "arima", "rw", "rwd", "wn",
"theta", "stlar", "nn", "snaive", "mstl", "tbats")
"arima" %in% models
train_test
sapply(train_test, ARIMA, ACCURACY=cal_WA)
a <- sapply(train_test, ARIMA, ACCURACY=cal_WA)
class(a)
class(a)["ARIMAaccuracy",]
a["ARIMAaccuracy",]
a[2,]
unlist(a[2,])
as.matrix(unlist(a[2,], ncol=1)
)
matrix(unlist(a[2,], ncol=1))
matrix(unlist(a[2,], ncols=1))
?matrix
lapply(train_test, ARIMA, ACCURACY=cal_WA)
a <- lapply(train_test, ARIMA, ACCURACY=cal_WA)
b <- lapply(a, function(temp){temp$ARIMAaccuracy})
b
b <- sapply(a, function(temp){temp$ARIMAaccuracy})
b
as.matrix(b)
a2 <- as.matrix(b)
a1 <- fcast_accuracy(tslist=tslist,models= c("rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
a1
a2
cbind(a1, a2)
lapply(train_test, ETS, ACCURACY=cal_WA)
#'
#' Calculate foecast accuracy on test set according to a specified citerion
#' @param y a univariate time series or a Mcomp object
#' @param h forecast horizon
#' @param database whether the time series is from mcomp or other
#' @param accuracyFunction function to calculate the accuracy measure, the arguments
#' for the accuracy function should be training, test and forecast
#' @return accuracy measure calculated based on each method
#' @author Thiyanga Talagala
#' @export
fcast_accuracy <- function(tslist, models = c("ets", "arima", "rw", "rwd", "wn",
"theta", "stlar", "nn", "snaive", "mstl", "tbats"), database
, accuracyFun, h){
if (database == "NULL") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
mat <- sapply(models, function(f){
switch(f,
rw = sapply(train_test, RW, ACCURACY=accuracyFun),
rwd = sapply(train_test, RWD, ACCURACY=accuracyFun),
wn = sapply(train_test, WN, ACCURACY=accuracyFun),
theta = sapply(train_test, THETA, ACCURACY=accuracyFun),
stlar = sapply(train_test, STLAR, ACCURACY=accuracyFun),
nn = sapply(train_test, NN, ACCURACY=accuracyFun),
snaive = sapply(train_test, SNAIVE, ACCURACY=accuracyFun),
mstl = sapply(train_test, MSTL, ACCURACY=accuracyFun),
tbats = sapply(train_test, TBATS, ACCURACY=accuracyFun)
)
})
if ("arima"%in% models) {
arima_cal <- lapply(train_test, ARIMA, ACCURACY=cal_WA)
arima_accuracy <- sapply(a, function(temp){temp$ARIMAaccuracy})
arima_models <- sapply(a, function(temp){temp$ARIMAmodel})
arima_mat <- as.matrix(arima_accuracy)
colnames(arima_mat) <- "arima"
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, ETS, ACCURACY=cal_WA)
ets_accuracy <- sapply(a, function(temp){temp$ETSaccuracy})
ets_models <- sapply(a, function(temp){temp$ETSmodel})
ets_mat <- as.matrix(ets_accuracy)
colnames(ets_mat) <- "ets"
}
return(list(accuracy=mat, ARIMA = arima_models, ETS=ets_models))
}
a1 <- fcast_accuracy(tslist=tslist,models= c("rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
#'
#' Calculate foecast accuracy on test set according to a specified citerion
#' @param y a univariate time series or a Mcomp object
#' @param h forecast horizon
#' @param database whether the time series is from mcomp or other
#' @param accuracyFunction function to calculate the accuracy measure, the arguments
#' for the accuracy function should be training, test and forecast
#' @return accuracy measure calculated based on each method
#' @author Thiyanga Talagala
#' @export
fcast_accuracy <- function(tslist, models = c("ets", "arima", "rw", "rwd", "wn",
"theta", "stlar", "nn", "snaive", "mstl", "tbats"), database
, accuracyFun, h){
if (database == "NULL") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
mat <- sapply(models, function(f){
switch(f,
rw = sapply(train_test, RW, ACCURACY=accuracyFun),
rwd = sapply(train_test, RWD, ACCURACY=accuracyFun),
wn = sapply(train_test, WN, ACCURACY=accuracyFun),
theta = sapply(train_test, THETA, ACCURACY=accuracyFun),
stlar = sapply(train_test, STLAR, ACCURACY=accuracyFun),
nn = sapply(train_test, NN, ACCURACY=accuracyFun),
snaive = sapply(train_test, SNAIVE, ACCURACY=accuracyFun),
mstl = sapply(train_test, MSTL, ACCURACY=accuracyFun),
tbats = sapply(train_test, TBATS, ACCURACY=accuracyFun)
)
})
if ("arima"%in% models) {
arima_cal <- lapply(train_test, ARIMA, ACCURACY=cal_WA)
arima_accuracy <- sapply(a, function(temp){temp$ARIMAaccuracy})
arima_models <<- sapply(a, function(temp){temp$ARIMAmodel})
arima_mat <- as.matrix(arima_accuracy)
colnames(arima_mat) <- "arima"
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, ETS, ACCURACY=cal_WA)
ets_accuracy <- sapply(a, function(temp){temp$ETSaccuracy})
ets_models <<- sapply(a, function(temp){temp$ETSmodel})
ets_mat <- as.matrix(ets_accuracy)
colnames(ets_mat) <- "ets"
}
return(list(accuracy=mat, ARIMA = arima_models, ETS=ets_models))
}
a1 <- fcast_accuracy(tslist=tslist,models= c("rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
arima_models <- NA
arima_models
#'
#' Calculate foecast accuracy on test set according to a specified citerion
#' @param y a univariate time series or a Mcomp object
#' @param h forecast horizon
#' @param database whether the time series is from mcomp or other
#' @param accuracyFunction function to calculate the accuracy measure, the arguments
#' for the accuracy function should be training, test and forecast
#' @return accuracy measure calculated based on each method
#' @author Thiyanga Talagala
#' @export
fcast_accuracy <- function(tslist, models = c("ets", "arima", "rw", "rwd", "wn",
"theta", "stlar", "nn", "snaive", "mstl", "tbats"), database
, accuracyFun, h){
arima_models <- NA
ets_models <- NA
if (database == "NULL") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
mat <- sapply(models, function(f){
switch(f,
rw = sapply(train_test, RW, ACCURACY=accuracyFun),
rwd = sapply(train_test, RWD, ACCURACY=accuracyFun),
wn = sapply(train_test, WN, ACCURACY=accuracyFun),
theta = sapply(train_test, THETA, ACCURACY=accuracyFun),
stlar = sapply(train_test, STLAR, ACCURACY=accuracyFun),
nn = sapply(train_test, NN, ACCURACY=accuracyFun),
snaive = sapply(train_test, SNAIVE, ACCURACY=accuracyFun),
mstl = sapply(train_test, MSTL, ACCURACY=accuracyFun),
tbats = sapply(train_test, TBATS, ACCURACY=accuracyFun)
)
})
if ("arima"%in% models) {
arima_cal <- lapply(train_test, ARIMA, ACCURACY=cal_WA)
arima_accuracy <- sapply(a, function(temp){temp$ARIMAaccuracy})
arima_models <- sapply(a, function(temp){temp$ARIMAmodel})
arima_mat <- as.matrix(arima_accuracy)
colnames(arima_mat) <- "arima"
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, ETS, ACCURACY=cal_WA)
ets_accuracy <- sapply(a, function(temp){temp$ETSaccuracy})
ets_models <- sapply(a, function(temp){temp$ETSmodel})
ets_mat <- as.matrix(ets_accuracy)
colnames(ets_mat) <- "ets"
}
return(list(accuracy=mat, ARIMA = arima_models, ETS =ets_models))
}
a1 <- fcast_accuracy(tslist=tslist,models= c("rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
a1
a1 <- fcast_accuracy(tslist=tslist,models= c("arima","rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
a1
?any
#'
#' Calculate foecast accuracy on test set according to a specified citerion
#' @param y a univariate time series or a Mcomp object
#' @param h forecast horizon
#' @param database whether the time series is from mcomp or other
#' @param accuracyFunction function to calculate the accuracy measure, the arguments
#' for the accuracy function should be training, test and forecast
#' @return accuracy measure calculated based on each method
#' @author Thiyanga Talagala
#' @export
fcast_accuracy <- function(tslist, models = c("ets", "arima", "rw", "rwd", "wn",
"theta", "stlar", "nn", "snaive", "mstl", "tbats"), database
, accuracyFun, h){
arima_models <- NA
ets_models <- NA
if (database == "NULL") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
mat <- sapply(models, function(f){
switch(f,
rw = sapply(train_test, RW, ACCURACY=accuracyFun),
rwd = sapply(train_test, RWD, ACCURACY=accuracyFun),
wn = sapply(train_test, WN, ACCURACY=accuracyFun),
theta = sapply(train_test, THETA, ACCURACY=accuracyFun),
stlar = sapply(train_test, STLAR, ACCURACY=accuracyFun),
nn = sapply(train_test, NN, ACCURACY=accuracyFun),
snaive = sapply(train_test, SNAIVE, ACCURACY=accuracyFun),
mstl = sapply(train_test, MSTL, ACCURACY=accuracyFun),
tbats = sapply(train_test, TBATS, ACCURACY=accuracyFun)
)
})
if ("arima"%in% models) {
arima_cal <- lapply(train_test, ARIMA, ACCURACY=cal_WA)
arima_accuracy <- sapply(a, function(temp){temp$ARIMAaccuracy})
arima_models <- sapply(a, function(temp){temp$ARIMAmodel})
arima_mat <- as.matrix(arima_accuracy)
colnames(arima_mat) <- "arima"
mat <- cbind(mat, arima_mat)
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, ETS, ACCURACY=cal_WA)
ets_accuracy <- sapply(a, function(temp){temp$ETSaccuracy})
ets_models <- sapply(a, function(temp){temp$ETSmodel})
ets_mat <- as.matrix(ets_accuracy)
colnames(ets_mat) <- "ets"
mat <- cbind(mat, ets_mat)
}
return(list(accuracy=mat, ARIMA = arima_models, ETS =ets_models))
}
a1 <- fcast_accuracy(tslist=tslist,models= c("arima","rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
#'
#' Calculate foecast accuracy on test set according to a specified citerion
#' @param y a univariate time series or a Mcomp object
#' @param h forecast horizon
#' @param database whether the time series is from mcomp or other
#' @param accuracyFunction function to calculate the accuracy measure, the arguments
#' for the accuracy function should be training, test and forecast
#' @return accuracy measure calculated based on each method
#' @author Thiyanga Talagala
#' @export
fcast_accuracy <- function(tslist, models = c("ets", "arima", "rw", "rwd", "wn",
"theta", "stlar", "nn", "snaive", "mstl", "tbats"), database
, accuracyFun, h){
arima_models <- NA
ets_models <- NA
if (database == "NULL") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
mat <- sapply(models, function(f){
switch(f,
rw = sapply(train_test, RW, ACCURACY=accuracyFun),
rwd = sapply(train_test, RWD, ACCURACY=accuracyFun),
wn = sapply(train_test, WN, ACCURACY=accuracyFun),
theta = sapply(train_test, THETA, ACCURACY=accuracyFun),
stlar = sapply(train_test, STLAR, ACCURACY=accuracyFun),
nn = sapply(train_test, NN, ACCURACY=accuracyFun),
snaive = sapply(train_test, SNAIVE, ACCURACY=accuracyFun),
mstl = sapply(train_test, MSTL, ACCURACY=accuracyFun),
tbats = sapply(train_test, TBATS, ACCURACY=accuracyFun)
)
})
if ("arima"%in% models) {
arima_cal <- lapply(train_test, ARIMA, ACCURACY=cal_WA)
arima_accuracy <- sapply(arima_cal, function(temp){temp$ARIMAaccuracy})
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
arima_mat <- as.matrix(arima_accuracy)
colnames(arima_mat) <- "arima"
mat <- cbind(mat, arima_mat)
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, ETS, ACCURACY=cal_WA)
ets_accuracy <- sapply(ets_cal, function(temp){temp$ETSaccuracy})
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
ets_mat <- as.matrix(ets_accuracy)
colnames(ets_mat) <- "ets"
mat <- cbind(mat, ets_mat)
}
return(list(accuracy=mat, ARIMA = arima_models, ETS =ets_models))
}
a1 <- fcast_accuracy(tslist=tslist,models= c("arima","rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
a1
a1
a2
a2[,2] <- c(1,2)
#'
#' Calculate foecast accuracy on test set according to a specified citerion
#' @param y a univariate time series or a Mcomp object
#' @param h forecast horizon
#' @param database whether the time series is from mcomp or other
#' @param accuracyFunction function to calculate the accuracy measure, the arguments
#' for the accuracy function should be training, test and forecast
#' @return accuracy measure calculated based on each method
#' @author Thiyanga Talagala
#' @export
fcast_accuracy <- function(tslist, models = c("ets", "arima", "rw", "rwd", "wn",
"theta", "stlar", "nn", "snaive", "mstl", "tbats"), database
, accuracyFun, h){
arima_models <- NA
ets_models <- NA
if (database == "NULL") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, ARIMA, ACCURACY=cal_WA)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, ETS, ACCURACY=cal_WA)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, RW, ACCURACY=accuracyFun),
rwd = sapply(train_test, RWD, ACCURACY=accuracyFun),
wn = sapply(train_test, WN, ACCURACY=accuracyFun),
theta = sapply(train_test, THETA, ACCURACY=accuracyFun),
stlar = sapply(train_test, STLAR, ACCURACY=accuracyFun),
nn = sapply(train_test, NN, ACCURACY=accuracyFun),
snaive = sapply(train_test, SNAIVE, ACCURACY=accuracyFun),
mstl = sapply(train_test, MSTL, ACCURACY=accuracyFun),
tbats = sapply(train_test, TBATS, ACCURACY=accuracyFun)
)
})
return(list(accuracy=mat, ARIMA = arima_models, ETS =ets_models))
}
a1 <- fcast_accuracy(tslist=tslist,models= c("arima","rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
a1
a1 <- fcast_accuracy(tslist=tslist,models= c("arima","ets","rw", "rwd", "theta", "stlar", "nn", "snaive", "mstl"),
database ="M3", cal_MASE, h=6)
a1
library(seer)
library(seer)
library(seer)
library(seer)
#' Computes relevant time series features before applying them to the model
#' @param ts_data_set a list of univariate time series
#' @param seasonal if FALSE, restricts to features suitable for non-seasonal data
#' @param m frequency of the time series
#' @param lagmax maximum lag at which to calculate the acf (quarterly series-5L and monthly-13L)
#' @param database whether the time series is from mcomp or other
#' @return dataframe: each column represent a feature and each row represent a time series
#' @importFrom magrittr %>%
#' @author Thiyanga Talagala
#' @export
cal_features <- function(ts_data_set, seasonal=FALSE, m=1, lagmax=2L, database){ # ts_data_set = yearly_m1,
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
train <- lapply(train_test, function(temp){temp$training})
ts_features_pkg <- tsfeatures::tsfeatures(train, c("entropy",
"lumpiness",
"stability",
"hurst",
"stl_features",
"acf_features",
"pacf_features",
"holt_parameters",
"nonlinearity"))
if (seasonal==FALSE){
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "alpha",
"beta","nonlinearity")
seer_features_nonseasonal <- lapply(ts_data_set, function(temp1){c(
e_acf1(temp1$x),
unitroot(temp1$x))})
seer_features_nonseasonal_DF <- as.data.frame(do.call("rbind", seer_features_nonseasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_nonseasonal_DF)
} else {
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "alpha",
"beta","nonlinearity", "seasonal_strength",
"seas_pacf")
seer_features_seasonal <- lapply(ts_data_set, function(temp1){c(holtWinter_parameters(temp1$x),
acf_seasonalDiff(temp1$x, m, lagmax))})
seer_features_seasonal_DF <- as.data.frame(do.call("rbind", seer_features_seasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_seasonal_DF)
}
ts_featuresDF <- as.data.frame(ts_features)
ts_featuresDF <- dplyr::rename(ts_featuresDF, "spikiness" = "spike")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_acf1" = "x_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_acf1" = "diff1_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_acf1" = "diff2_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_pacf5" = "x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_pacf5" = "diff1x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_pacf5" = "diff2x_pacf5")
if(seasonal==TRUE){
ts_featuresDF <- dplyr::rename(ts_featuresDF, "seasonality" = "seasonal_strength")
}
length <- lapply(ts_data_set, function(temp){length(temp$x)})
length <- unlist(length)
ts_featuresDF$N <- length
seer_features <- lapply(ts_data_set, function(temp1){acf5(temp1$x)})
seer_feature_DF <- as.data.frame(do.call("rbind", seer_features))
featureDF <- dplyr::bind_cols(ts_featuresDF,seer_feature_DF)
return(featureDF)
}
require(Mcomp)
data(M3)
yearly_m3 <- subset(M3, "yearly")
cal_features(yearly_m3, database="M3")
library(seer)
library(seer)
library(seer)
library(seer)
library(seer)
devtools::install_github("robjhyndman/tsfeatures")
library(tsfeatures)
hurst(rnorm(10))
unitroot_kpss(rnom(10))
unitroot_kpss(rnorm(10))
stl_features(rnorm(10))
auto.arima(M3[[2]]$x)
rwf(M3[[2]]$x)
library(seer)
RWD <- function(ts_info, ACCURACY){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
rwd_fit <- rwf(training,drift=TRUE, h=h)
forecastRWD <- forecast(rwd_fit)$mean
RWDaccuracy <- ACCURACY(forecast=forecastRWD, test=test, training=training)
return(RWDaccuracy)
}
RWD(M[[2]]$x, cal_MASE())
RWD(M[[2]]$x, cal_MASE)
RWD(M3[[2]]$x, cal_MASE)
library(Mcomp)
RWD(M3[[2]]$x, cal_MASE)
RWD(M3[[2]], cal_MASE)
tsinfo <- list(training=M3[[2]]$x, test=M3[[2]]$xx)
RWD(tsinfo, cal_MASE)
ARIMA(tsinfo, cal_MASE)
?rwf
rwf(M3[[1]]$x)
ARIMA(tsinfo, cal_MASE)
auto.arima(M3[[3]]$x)
auto.arima(M3[[300]]$x)
auto.arima(M3[[645]]$x)
