Mcomp.sub
Mcomp::subset.Mcomp()
Mcomp::subset.Mcomp
?subset
Mcomp::subset.Mcomp()
Mcomp::subset.Mcomp
M4_hourly <- subset(M4, "Monthly")
M_hourly
M4_hourly
M4_hourly <- subset(M4, "Demographic")
M4_hourly
M4_hourly <- subset(M4, "Weekly")
M4_hourly <- subset(M4, "WEEKLY")
M4_hourly <- subset(M4, "Finance")
M4_hourly
M4
M4_hourly <- filter(M4, "Hourly")
M4_hourly <- filter(M4, "Othe")
M4_hourly <- filter(M4, "Other")
M4_hourly <- subset(M4, "Other")
M4_hourly <- subset(M4, "OTHER")
M4_hourly <- subset(M4, "FIN")
M4_hourly <- subset(M4, "OTH")
M4_hourly <- subset(M4, "Weekly")
M4_hourly <- subset(M4, "Daily")
M4_hourly <- subset(M4, "Y")
plot(M4[[1]])
plot(M4[[1]]$x)
plot(M3[[1]])
plot(M4[[1]])
M4
#' @export
Mcomp.sub <- function(x,getdata)
{
n <- length(x)
Type <- Period <- character(n)
for(i in 1:n)
{
Type[i] <- x[[i]]$type
if(Type[i]=="INDUSTRIAL")
Type[i] <- "INDUST"
if(strsplit(Type[i],"-")=="DEMOGRAPHI")
Type[i] <- "DEMOGRAPHIC"
Period[i] <- x[[i]]$period
}
getdatatable <- c("yearly","quarterly","monthly","hourly","weekly","daily","other","macro","micro","industry",
"finance","demographic","allother","macro1","macro2","micro1","micro2","micro3")
if(is.character(getdata))
{
getdata <- getdatatable[charmatch(getdata,getdatatable)]
if(length(getdata) != 1)
stop("Ambiguous data type")
else if(is.na(getdata))
stop("Unknown data type")
}
if(getdata==1 | getdata=="yearly")
choose <- (Period=="YEARLY")
else if(getdata==4 | getdata=="quarterly")
choose <- (Period=="QUARTERLY")
else if(getdata==12 | getdata=="monthly")
choose <- (Period=="MONTHLY")
else if(getdata==52 | getdata=="weekly")
choose <- (Period=="WEEKLY")
else if(getdata==24 | getdata=="hourly")
choose <- (Period=="HOURLY")
else if(getdata==365 | getdata=="daily")
choose <- (Period=="DAILY")
else if(getdata==111)
{
j <- match(x111,names(x))
choose <- rep(FALSE,length(x))
choose[j] <- TRUE
}
else if(getdata=="other")
choose <- (Period=="OTHER")
else if(getdata=="macro")
choose <- (Type=="MACRO")
else if(getdata=="micro")
choose <- (Type=="MICRO")
else if(getdata=="industry")
choose <- (Type=="INDUSTRY" | Type=="INDUST")
else if(getdata=="finance")
choose <- (Type=="FINANCE")
else if(getdata=="demographic")
choose <- (Type=="DEMOGRAPHIC" | Type=="DEMOGR")
else if(getdata=="allother")
choose <- (Type=="OTHER")
else if(getdata=="macro1")
choose <- (Type=="MACRO1")
else if(getdata=="macro2")
choose <- (Type=="MACRO2")
else if(getdata=="micro1")
choose <- (Type=="MICRO1")
else if(getdata=="micro2")
choose <- (Type=="MICRO2")
else if(getdata=="micro3")
choose <- (Type=="MICRO3")
else
stop("Unknown type or period")
if(sum(choose) == 0)
stop("No data")
return(x[choose])
}
#' @author Thiyanga Talagala
#' @references
#' @keywords data
#' @examples
#'
#' M3.quarterly <- subset(M3,4)
#' M1.yearly.industry <- subset(M1,1,"industry")
#' @export
#' @export subset.Mcomp
#'
subset.Mcomp <- function(x,cond1,cond2,...)
{
if(is.character(cond1))
cond1 <- tolower(cond1)
M11=structure(Mcomp.sub(x,cond1),class="Mcomp")
if(!missing(cond2))
{
if(is.character(cond2))
cond2 <- tolower(cond2)
M12=structure(Mcomp.sub(M11,cond2),class="Mcomp")
return(M12)
}
else
return(M11)
}
#' @export
`[.Mcomp` <- function(x, i)
{
y <- NextMethod("[")
class(y) <- c("Mcomp", class(y))
y
}
m4h <- subset(M4, "hourly")
m4h <- subset(M4, "Hourly")
m4h
citation("Mcomp")
citation("mozzie")
citation("colmozzie")
library(seer)
M4
m4h <- subset(M4, "Hourly")
m4h
m4h <- subset(M4, "Daily")
m4h
#' The following code is taken from Mcomp package and done some
#' small tweaks to handle hourly, daily and weekly data in M4 competition.
#' @param x whether the data are from M1, M3 or M4
#' @param getdata condition: daily, monthly, demographic, etc.
#' @export
Mcomp.sub <- function(x,getdata)
{
n <- length(x)
Type <- Period <- character(n)
for(i in 1:n)
{
Type[i] <- x[[i]]$type
if(Type[i]=="INDUSTRIAL")
Type[i] <- "INDUST"
if(strsplit(Type[i],"-")=="DEMOGRAPHI")
Type[i] <- "DEMOGRAPHIC"
Period[i] <- x[[i]]$period
}
getdatatable <- c("yearly","quarterly","monthly","hourly","weekly","daily","other","macro","micro","industry",
"finance","demographic","allother","macro1","macro2","micro1","micro2","micro3")
if(is.character(getdata))
{
getdata <- getdatatable[charmatch(getdata,getdatatable)]
if(length(getdata) != 1)
stop("Ambiguous data type")
else if(is.na(getdata))
stop("Unknown data type")
}
if(getdata==1 | getdata=="yearly")
choose <- (Period=="YEARLY")
else if(getdata==4 | getdata=="quarterly")
choose <- (Period=="QUARTERLY")
else if(getdata==12 | getdata=="monthly")
choose <- (Period=="MONTHLY")
else if(getdata==52 | getdata=="weekly")
choose <- (Period=="WEEKLY")
else if(getdata==24 | getdata=="hourly")
choose <- (Period=="HOURLY")
else if(getdata==365 | getdata=="daily")
choose <- (Period=="DAILY")
#else if(getdata==111)
#{
#    j <- match(x111,names(x))
#    choose <- rep(FALSE,length(x))
#    choose[j] <- TRUE
#   }
else if(getdata=="other")
choose <- (Period=="OTHER")
else if(getdata=="macro")
choose <- (Type=="MACRO")
else if(getdata=="micro")
choose <- (Type=="MICRO")
else if(getdata=="industry")
choose <- (Type=="INDUSTRY" | Type=="INDUST")
else if(getdata=="finance")
choose <- (Type=="FINANCE")
else if(getdata=="demographic")
choose <- (Type=="DEMOGRAPHIC" | Type=="DEMOGR")
else if(getdata=="allother")
choose <- (Type=="OTHER")
else if(getdata=="macro1")
choose <- (Type=="MACRO1")
else if(getdata=="macro2")
choose <- (Type=="MACRO2")
else if(getdata=="micro1")
choose <- (Type=="MICRO1")
else if(getdata=="micro2")
choose <- (Type=="MICRO2")
else if(getdata=="micro3")
choose <- (Type=="MICRO3")
else
stop("Unknown type or period")
if(sum(choose) == 0)
stop("No data")
return(x[choose])
}
#' @return An object of class \code{Mcomp} consisting of the selected series.
#' @references Rob Hyndman (2018). Mcomp: Data from the M-Competitions. R package version 2.7. https://CRAN.R-project.org/package=Mcomp
#' @keywords data
#' @examples
#'
#' M3.quarterly <- subset(M3,4)
#' M1.yearly.industry <- subset(M1,1,"industry")
#' @export
#' @export subset.Mcomp
#'
subset.Mcomp <- function(x,cond1,cond2,...)
{
if(is.character(cond1))
cond1 <- tolower(cond1)
M11=structure(Mcomp.sub(x,cond1),class="Mcomp")
if(!missing(cond2))
{
if(is.character(cond2))
cond2 <- tolower(cond2)
M12=structure(Mcomp.sub(M11,cond2),class="Mcomp")
return(M12)
}
else
return(M11)
}
#' @export
`[.Mcomp` <- function(x, i)
{
y <- NextMethod("[")
class(y) <- c("Mcomp", class(y))
y
}
subset(M4, "daily")
subset(M3, "daily")
subset(M3, "yearly")
library(seer)
subset(M4, 4)
subset(M4,1,"industry")
library(seer)
library(seer)
library(seer)
#' @param y a time series or M-competition data time series (Mcomp)
#' @param Nsim number of time series to simulate
#' @param Combine if TRUE, training and test data in the M-competition data are combined and generate a time
#' series corresponds to the full length of the series. Otherwise, it generate a time series
#' based on the training period of the series.
#' @param M if TRUE, y is considered to be a Mcomp data object
#' @return A list of time series.
#' @author Thiyanga Talagala
#' @import forecast
#' @export
sim_arimabased <- function(y, Nsim, Combine=TRUE, M=TRUE, Future=FALSE, Length=NULL){
if (M ==TRUE){
if ("Combine"==TRUE){
train <- y$x
test <-  y$xx
combined <- ts.union(train, test)
combined <- pmin(combined[,1], combined[,2], na.rm = TRUE)
}else{
combined <- y$x}
}else{
combined <- y
}
fit <- auto.arima(combined)
if (Length!= NULL){length_series <- Length
} else {
length_series <- length(combined)
}
mat <- list()
for(i in 1:Nsim){
mat[[i]] <- simulate(fit, nsim=length_series, future=FALSE)}
return (mat)
}
y <- rnorm(10)
sim_arimabased(y, Nsom=2, Combine=F, M=F, F=T, Length = 5)
sim_arimabased(y, Nsim=2, Combine=F, M=F, F=T, Length = 5)
library(forecast)
sim_arimabased(y, Nsim=2, Combine=F, M=F, F=T, Length = 5)
#' @param y a time series or M-competition data time series (Mcomp)
#' @param Nsim number of time series to simulate
#' @param Combine if TRUE, training and test data in the M-competition data are combined and generate a time
#' series corresponds to the full length of the series. Otherwise, it generate a time series
#' based on the training period of the series.
#' @param M if TRUE, y is considered to be a Mcomp data object
#' @return A list of time series.
#' @author Thiyanga Talagala
#' @import forecast
#' @export
sim_arimabased <- function(y, Nsim, Combine=TRUE, M=TRUE, Future=FALSE, Length=NA){
if (M ==TRUE){
if ("Combine"==TRUE){
train <- y$x
test <-  y$xx
combined <- ts.union(train, test)
combined <- pmin(combined[,1], combined[,2], na.rm = TRUE)
}else{
combined <- y$x}
}else{
combined <- y
}
fit <- auto.arima(combined)
if (Length!= NA){length_series <- Length
} else {
length_series <- length(combined)
}
mat <- list()
for(i in 1:Nsim){
mat[[i]] <- simulate(fit, nsim=length_series, future=FALSE)}
return (mat)
}
#' @param y a time series or M-competition data time series (Mcomp)
#' @param Nsim number of time series to simulate
#' @param Combine if TRUE, training and test data in the M-competition data are combined and generate a time
#' series corresponds to the full length of the series. Otherwise, it generate a time series
#' based on the training period of the series.
#' @param M if TRUE, y is considered to be a Mcomp data object
#' @return A list of time series.
#' @author Thiyanga Talagala
#' @import forecast
#' @export
sim_arimabased <- function(y, Nsim, Combine=TRUE, M=TRUE, Future=FALSE, Length=NA){
if (M ==TRUE){
if ("Combine"==TRUE){
train <- y$x
test <-  y$xx
combined <- ts.union(train, test)
combined <- pmin(combined[,1], combined[,2], na.rm = TRUE)
}else{
combined <- y$x}
}else{
combined <- y
}
fit <- auto.arima(combined)
if (Length!=NA){length_series <- Length
} else {
length_series <- length(combined)
}
mat <- list()
for(i in 1:Nsim){
mat[[i]] <- simulate(fit, nsim=length_series, future=FALSE)}
return (mat)
}
sim_arimabased(y, Nsim=2, Combine=F, M=F, F=T, Length = 5)
Length = NA
Length!=NA
Length == NA
Length = 1
Length==1
Length=NA
is.na(Length)
!is.na(Length)
#' @param y a time series or M-competition data time series (Mcomp)
#' @param Nsim number of time series to simulate
#' @param Combine if TRUE, training and test data in the M-competition data are combined and generate a time
#' series corresponds to the full length of the series. Otherwise, it generate a time series
#' based on the training period of the series.
#' @param M if TRUE, y is considered to be a Mcomp data object
#' @return A list of time series.
#' @author Thiyanga Talagala
#' @import forecast
#' @export
sim_arimabased <- function(y, Nsim, Combine=TRUE, M=TRUE, Future=FALSE, Length=NA){
if (M ==TRUE){
if ("Combine"==TRUE){
train <- y$x
test <-  y$xx
combined <- ts.union(train, test)
combined <- pmin(combined[,1], combined[,2], na.rm = TRUE)
}else{
combined <- y$x}
}else{
combined <- y
}
fit <- auto.arima(combined)
if (!is.na(Length)){length_series <- Length
} else {
length_series <- length(combined)
}
mat <- list()
for(i in 1:Nsim){
mat[[i]] <- simulate(fit, nsim=length_series, future=FALSE)}
return (mat)
}
sim_arimabased(y, Nsim=2, Combine=F, M=F, F=T, Length = 5)
#' @param y a time series or M-competition data time series (Mcomp)
#' @param Nsim number of time series to simulate
#' @param Combine if TRUE, training and test data in the M-competition data are combined and generate a time
#' series corresponds to the full length of the series. Otherwise, it generate a time series
#' based on the training period of the series.
#' @param M if TRUE, y is considered to be a Mcomp data object
#' @return A list of time series.
#' @author Thiyanga Talagala
#' @import forecast
#' @export
sim_arimabased <- function(y, Nsim, Combine=TRUE, M=TRUE, Future=FALSE, Length=NA){
if (M ==TRUE){
if ("Combine"==TRUE){
train <- y$x
test <-  y$xx
combined <- ts.union(train, test)
combined <- pmin(combined[,1], combined[,2], na.rm = TRUE)
}else{
combined <- y$x}
}else{
combined <- y
}
fit <- auto.arima(combined)
if (!is.na(Length)){length_series <- Length
} else {
length_series <- length(combined)
}
mat <- list()
for(i in 1:Nsim){
mat[[i]] <- simulate(fit, nsim=length_series, future=Future)}
return (mat)
}
sim_arimabased(y, Nsim=2, Combine=F, M=F, F=T, Length = 5)
library(seer)
library(seer)
#' @param M if TRUE, y is considered to be a Mcomp data object
#' @param Future  So if future=TRUE, the simulated observations are conditional on the historical observations.
#' In other words, they are possible future sample paths of the time series. But if future=FALSE, the historical
#' data are ignored, and the simulations are possible realizations of the time series model that
#' are not connected to the original data.
#' @param Length length of the simulated time series. If future = FALSE, the Length agument should be NA.
#' @return A list of time series.
#' @author Thiyanga Talagala
#' @import forecast
#' @export
sim_etsbased <- function(y, Nsim, Combine=TRUE, M=TRUE, Future=FALSE, Length=NA){
if (M ==TRUE){
if ("Combine"==TRUE){
train <- y$x
test <-  y$xx
combined <- ts.union(train, test)
combined <- pmin(combined[,1], combined[,2], na.rm = TRUE)
}else{
combined <- y$x}
}else{
combined <- y
}
fit <- ets(combined)
if (!is.na(Length)){length_series <- Length
} else {
length_series <- length(combined)
}
mat <- list()
for(i in 1:Nsim){
mat[[i]] <- simulate(fit, nsim=length_series, future=FALSE)}
return (mat)
}
require(Mcomp)
libray(seer)
library(seer)
quaterly_m3 <- subset(M3, "yearly")
sim_etsbased(quarterly_m3[[1]], 2, Combine=TRUE, M=TRUE, Future=FALSE)
set.seed(1)
tsy <- ts(rnorm(8), frequency=1)
sim_etsbased(tsy, 2, Combine=FALSE, M=FALSE, Future=TRUE, Length=5)
?simulate
library(seer)
devtools::install_github("robjhyndman/forecast")
?lmtest
??lmtest
help("lmtest")
version(forecast)
library(devtools)
devtools::install_github("robjhyndman/forecast")
install.packages("curl")
install.packages("curl")
devtools::install_github("robjhyndman/forecast")
install.packages("curl")
library(curl)
remove.packages("curl")
remove.packages("forecast")
remove.packages("lmtest")
devtools::install_github("robjhyndman/forecast")
devtools::install_github("robjhyndman/forecast")
?install_github
devtools::install_github("robjhyndman/forecast", dependencies=T)
install.packages("curl")
library(curl)
devtools::install_github("robjhyndman/forecast", dependencies=T)
library(forecast)
library(seer)
?mapply(function, ...)
?mapply
install.packages("dplyr")
version
